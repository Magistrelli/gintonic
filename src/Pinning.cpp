#include "./Pinning.h"


// CONSTRUCTORS

// Default constructor: initializes all the numerical variables to 0 or 0.
//  and all the strings to ""
Pinning::Pinning(): _type(""), _str(0.), _sigma(0.), \
                    _xp(NULL), _Lx(0.), _Ly(0.), _nX(0), _nY(0) {}


Pinning::Pinning(const string type, const bool ifActivePart,
    const vector<double> pinParams, vector<unsigned int> npin): Pinning() {
    /*
    Constructs a Pinning instance describing a pinning potential of a
        specified shape
    
    :arg: <type>          'cos', 'gauss' or 'rod, specifies the shape of the
                          pinning potential's peaks
    :arg: <ifActivePart>  if the pinning landscape is generated by active
                          particles which dynamically interact with the
                          superfluid
    :arg: <pinParams>     vector<double> of legth 6, <pinParams> = (<str>,
                          <sigma>, <x0>, <y0>, <Lx>, <Ly>), where <str> gives
                          the strength of the pinning potential's peaks (their
                          maximum value), <sigma> the width of its peaks (not
                          use for a 'cos' potential), <x0>, <y0> the
                          coordinates of a certain reference peak of the
                          potential, <Lx>, <Ly> the dimensions of the simulated
                          (fundamental) cell
    :arg: <npin>          vector<unsigned int> of length 2 giving the number of
                          pinning's peaks along the two cartesian axes
    */

    // internal variables
    double posx, posy;

    // check the shape of the arguments given to this method
    if (pinParams.size() != 6) {
        cerr << "<pinParams> must have 6 elements!" << endl; exit(-100);
    }
    if  (npin.size() != 2) {
        cerr << "<npin> must have 2 elements!" << endl; exit(-101);
    }
    // store the arguments of this methods in the internal variables
    _type = type;
    _ifActivePart = ifActivePart;
    _str = pinParams[0];
    _sigma = pinParams[1];
    double x0 = pinParams[2];
    double y0 = pinParams[3];
    _Lx = pinParams[4];
    _Ly = pinParams[5];
    _nX = npin[0];
    _nY = npin[1];

    // ActiveParticles for gaussian rods not yet implemented
    if (_ifActivePart) {
        // check input concistency
        if (_type != "gauss") {
            throw std::runtime_error("The dynamic of the background potential \
                    is implemented only for gaussian point-like particles!");
        }
    }

    // define dynamic particles positions
    _xp = new Vector2[_nX*_nY];
    // compute the positions of the equally spaced peaks employing PBC
    for (unsigned int i = 0; i < _nX; i++) {
        for (unsigned int j = 0; j < _nY; j++) {
            posx = x0 + i*_Lx/_nX;
            while (posx > _Lx/2.) {posx-=_Lx;}
            posy = y0 + j*_Ly/_nY;
            while (posy > _Ly/2.) {posy-=_Ly;}
            _xp[_nY*i + j] = Vector2(posx, posy);
        }
    }
}


// destructor
Pinning::~Pinning() {
    delete[] _xp;
}



// PUBLIC FUNCTIONS

double Pinning::Eval(const double x, const double y) const {
    /*
    Evaluates the pinning potential in a specific point
    They are implemented only cosine, gaussian, and gaussian rods pinning
        potential with an arbitrary number of equally spaced, identical peaks
    The internal variables of the Pinning's instance specify the potential's
        strength, peaks' width, number and positions
    The distances between the point given as argument and the refeernce peak's
        position are computed in PBC (see './functions.cpp)'
    
    :arg: <x>   x-coordinate of the evalation point
    :arg: <y>   y-coordinate of the evalation point
    
    Returns the value of the pinning potential in (x,y)
    */

    // cosine pinning potential
    if (_type == "cos") {
      // rescale x and y to have a cosine with _nX*_nY peaks;
      //  one of those peaks is centered in (_x0,_y0)
      double newx = 2.*_nX*M_PI * pbcDistance(x, _xp[0][0], _Lx) /_Lx;
      double newy = 2.*_nY*M_PI * pbcDistance(y, _xp[0][1], _Ly) /_Ly;
      // evaluate the pinning potential
      return _str*cos(newx)*cos(newy);

    // gaussian peaks pinning potential
    } else if (_type == "gauss") {
      // compute the pinning potential summing all the gaussian contributes
      //  from the single gaussian peaks
      double pin = 0.;
      for (unsigned int jpeak = 0; jpeak < _nX*_nY; jpeak++)
          pin += EvalPeak(x, y, jpeak);
      return pin;

    // gaussian rods pinning potential
    } else if (_type == "rod") {
      // compute the pinning potential summing all the gaussian contributes
      //  from the single gaussian rods
      double pin = 0.;
      for (unsigned int i = 0; i < _nX; i++) {
        pin += _str \
                * exp(-0.5*pow(pbcDistance(x, _xp[_nY*i][0], _Lx)/_sigma, 2));
      }
      return pin;

    } else {
      throw std::runtime_error("only cosine <cos>, gaussian (peaks) <gauss> \
                    and gaussian rod <rod> pinning potential are implemented");
    }
}

double Pinning::EvalPeak(const double x, const double y, \
                         const unsigned int jpeak) const {
    /*
    :arg: <x>   x-coordinate of the evalation point
    :arg: <y>   y-coordinate of the evalation point
    */

    // gaussian peaks pinning potential
    if (_type != "gauss") {
        throw std::runtime_error("only gaussian <gauss> pinning potential \
                                  is implemented!");
    }

    // compute the pinning potential summing all the gaussian contributes
    //  from the single gaussian peaks
    double pin;
    pin = _str * exp(-0.5*pow(pbcDistance(x, _xp[jpeak][0], _Lx)/_sigma, 2)) \
               * exp(-0.5*pow(pbcDistance(y, _xp[jpeak][1], _Ly)/_sigma, 2));
    return pin;
}



void Pinning::SetNewPos(const Vector2 * const xp) {
    for (unsigned int ipart = 0; ipart < _nX*_nY; ipart++) {
        _xp[ipart] = xp[ipart];
    }
}
